=begin

  Gemini Translator To-be class.

=end
require 'rainbow'
require 'pry'
require 'front_matter_parser'
require 'yaml'
require 'digest'
require 'date' # For psych :: Date to import from YAML..

FMPLoader ||= FrontMatterParser::Loader::Yaml.new(allowlist_classes: [Time, Date])

# CHANGELOG
#  2024-10-27 v1.5 Changed prompt to say ensure the double qutoes at beginning and end of it.
#  2024-10-27 v1.4 Removed golang comments - before first --- they break everything..
#  2024-10-26 v1.3 Fixed the <!-- -->  into a golang comment
#  2024-10-23 v1.2 Added other field to the file. Also added TXT to cache for easy of finding empty stuff. With the YAML is hard to see if it produces bogus output,
#                  since INPUT is always chubby.
#  2024-10-20 v1.0 first stesure
#  2024-10-20 v1.1 Added geminocks+lang to prompt => into tags.
TranslatorVersion = '1.5'


def golang_comment(str)
  str.split("\n").map{|line|  "{{/* #{line}  */}}\n"  }.join("")
end

def llm
  Langchain.logger.level = Logger::INFO

  Langchain::LLM::GoogleGemini.new(
    api_key: ENV["GEMINI_API_KEY"],
    default_options: {
      #temperature: 0.7,
      chat_completion_model_name: GEMINI_MODEL, # "gemini-1.5-pro"
    }
  )
end

def short_lang_to_long(lang:)
  return 'German' if lang == 'de'
  return 'English' if lang == 'en'
  return 'French' if lang == 'fr'
  return 'Italian' if lang == 'it'
  return 'Japanese' if lang == 'jp'
  raise "Unknown language: #{lang}"
end

def matter_hash_to_str(h)
#  "---\n#{h.map{|k, v|  "#{k}: #{v}\n"}.join("\n\n")}---\n" # TODO sanitize
  #puts(h.to_yaml)
  h.to_yaml.to_s +
  "# Generated by Geminock v.#{TranslatorVersion} - matter_hash_to_str()\n" +
  "# Note this operation might have removed all previous comments. Sorry.\n" +
  "# If Riccardo wants to edit this, code is in: #{__FILE__}\n" +
  "---\n"
end

# https://stackoverflow.com/questions/4823468/comments-in-markdown
def add_markdown_comment(comment:)
  "[comment]: <> #{comment}"
end
#parsed = FrontMatterParser::Parser.parse_file('example.md')
def translate_title(title:, lang: )
  "[TODO] [#{lang}] #{title}".gsub('Geminocks', 'ðŸŽŒGemiNoTrnsl')
end

def extract_title_from_content(markdown_content:)
#  match = markdown_content.match(/^title: "(.*)"$/)

  title = markdown_content.split("\n").select{|l| l =~ /^title:/}.first.split(': ')[1] rescue nil

  if title
    #title = match[1]
    return title  # Output the extracted title
  else
    puts "extract_title_from_content(): Title not found in the markdown_content: '''#{markdown_content[0..200]}...'''"
    binding.pry
    raise "Exception title not found for markdown: .."
    return nil
  end
end

def alter_front_matter(file_name:,  extension:, lang:)
  alter_front_matter_version = '1.0'

  puts("alter_front_matter:: Altering headers for file_name: #{Rainbow(file_name).cyan}")
  parsed = FrontMatterParser::Parser.parse_file(file_name, loader: FMPLoader)
  # front_matter to hash
  altered_fm = parsed.front_matter
  #altered_fm ||= {} # Sometimes its empty - so be it
  raise "Empty FrontMatter for '#{file_name}'. Before ROCKING it, please add some --- stuff ---, thanks!" if altered_fm.nil?
  binding.pry if altered_fm.nil?
  altered_fm['geminock'] = {
    'alter_front_matter_version': alter_front_matter_version,
    'notes': 'Riccardo - todo make this variable per extension and calla  proper class to get it. So you can have a single thingie for Main picture, and then transform it for all extensions.'
  }
  parsed_title = parsed.front_matter['title']
  altered_fm['title'] = translate_title(
    title: parsed_title, # parsed.front_matter['title'],
    lang:)
  Langchain.logger.info("front_matter title: '#{Rainbow(parsed_title).cyan}'")

  return altered_fm
end

# Calling Langchain
def call_gemini_on_content(markdown_content:, lang:) # , refresh_cache: false)
  #puts("Original markdown_content: #{markdown_content}")

  prompt = Langchain::Prompt::PromptTemplate.new(
    template:File.read('etc/prompts/translate-to-another-language.prompt'),
    input_variables: ["full_name", "language", "original_content"]
  )

  formatted_prompt = prompt.format(
    original_content: markdown_content,
    language: short_lang_to_long(lang: ),
    full_name: 'Dr Riccardo Carlesso',
    )
  # DEBUG
  title = extract_title_from_content(markdown_content:)

  # Generate a unique cache key based on content hash and language
  FileUtils.mkdir_p('.cache/')
  # Calculate MD5 of the original content - nah i already have the SHA256
  #content_md5 = Digest::MD5.hexdigest(markdown_content)
  original_article_hash = Digest::SHA256.hexdigest(markdown_content)
  cache_key = original_article_hash + "-#{lang}.yaml"
  cache_file = ".cache/#{cache_key}"

  # Check for cached translation if overwrite is false and cache file exists
#  if !refresh_cache && File.exist?(cache_file)
  if File.exist?(cache_file)
    Langchain.logger.info("#{self.class} - â™»ï¸ Cache hit for #{cache_key.to_s[0..50]}...")
      # Read cached translation from YAML
    cached_data = YAML.load_file(cache_file)
    # Check if the cached input matches the current input
    if cached_data && cached_data["input"] == markdown_content
      # hugo comment
      drugged_output =
        # This breaks everything
        #golang_comment("Generated by Geminock v#{TranslatorVersion} . cache_key='#{cache_key}' ") +
        cached_data["output"].inject_in_front_matter("Generated by Geminock v#{TranslatorVersion} . cache_key='#{cache_key}' ")

      return drugged_output # cached_data["output"]
    end
    #return cached_data["output"] if cached_data && cached_data["input"] == markdown_content
  end

  Langchain.logger.info("#{self.class} - â™»ï¸ Cache MISS for #{cache_key.to_s[0..50]}...")

  messages = [
    { role: "user", parts: [{ text: formatted_prompt }]}
  ]
  puts("Calling Gemini on hashed content '#{original_article_hash}' (lang= #{lang}))..")
  #puts(formatted_prompt)
  response = llm.chat(messages: messages)

  # Prepare data for caching: input and output
  cache_data = {
    "input" => markdown_content,
    "output" => response.chat_completion, # ["messages"][0]["content"]
    "model" => GEMINI_MODEL,
    "code_version" => TranslatorVersion,
    'article_hash' => original_article_hash,
    'title' => title,
    'lang' => lang,
  }


  # Write the translation to the cache file
  File.open(cache_file, 'w') { |f| f.write(cache_data.to_yaml) }
  File.open(cache_file + ".txt", 'w') { |f| f.write(response.chat_completion) } # output

  binding.pry if cache_data["output"].nil?

  # Return the translated content
  return cache_data["output"]

end

# This translates EVERYTHING, matter and content. Maybe I should just translate the content.
# TODO(rename to sth without translate..)
def translate_with_gemini(file_name:, extension:, lang:, output_file: , overwrite: false)
  # CHANGELOG:
  # 2024-10-20 v1.0 First iteration
  # 2024-10-20 v1.1 Add a "[Geminocks]" to title:
  # 2024-10-20 v1.2 Try to avoid the ``` output.
  # 2024-10-20 v1.4 Added geminocks to tags
  prompt_version = '1.4'

  puts(Rainbow("WARNING! overwrite is TRUE! Gemini will now overwrite markdown file '#{output_file}' !!").red) if overwrite
  markdown_content = File.read(file_name)
  comment_ad_minchiam = "translate_with_gemini(file_name: #{file_name}, extension: #{extension}, lang: #{lang}). MD_content: #{markdown_content.length/1024}KB. prompt_version=#{prompt_version}"

  new_matter = alter_front_matter(file_name:,  extension:, lang:)

  # Geminize the whole stuff
  if ENABLE_GEMINI
    response_chat_completion = call_gemini_on_content(markdown_content: markdown_content, lang:)

    binding.pry if response_chat_completion.nil?

    # TODO do it well with https://www.rubydoc.info/gems/front_matter_parser/0.0.4

    gemini_output = response_chat_completion + "\n\n*(Generated by Geminocks: https://github.com/palladius/ricc.rocks/tree/main/gemini prompt_version=#{prompt_version})*"

  else
      puts("[TranslWGemini] no gemini BUT - let me just pass whatever i have in input and just do the FrontMatter magic. This is usually done in DEV mode for fast feedback loop")
      parsed = FrontMatterParser::Parser.parse_file(file_name, loader: FMPLoader)
      new_doc_ohne_translation = matter_hash_to_str(new_matter) + "\n*[geminickl : DISABLED TRANSLATION BRO]*\n\n#{parsed.content}\n\nTHIS WAS ORIGINAL PARSED CONTENT"
      gemini_output = new_doc_ohne_translation
    end
  # Write the modified content back to the output file
  ret = File.write(output_file, gemini_output)
  puts("[#{ret}] Just wrote MD to '#{output_file}'")
  return ret
end
