=begin

  Gemini Translator To-be class.

=end
require 'rainbow'
require 'pry'
require 'front_matter_parser'
require 'yaml'
require 'digest'
require 'date' # For psych :: Date to import from YAML..

FMPLoader ||= FrontMatterParser::Loader::Yaml.new(allowlist_classes: [Time, Date])

TranslatorVersion = '1.0'

def llm
  Langchain.logger.level = Logger::INFO

  Langchain::LLM::GoogleGemini.new(
    api_key: ENV["GEMINI_API_KEY"],
    default_options: {
      #temperature: 0.7,
      chat_completion_model_name: GEMINI_MODEL, # "gemini-1.5-pro"
    }
  )
end

def short_lang_to_long(lang:)
  return 'Italian' if lang == 'it'
  return 'English' if lang == 'en'
  return 'French' if lang == 'fr'
  raise "Unknown language: #{lang}"
end

def matter_hash_to_str(h)
#  "---\n#{h.map{|k, v|  "#{k}: #{v}\n"}.join("\n\n")}---\n" # TODO sanitize
  #puts(h.to_yaml)
  h.to_yaml.to_s +
  "# Generated by Geminock v.#{TranslatorVersion} - matter_hash_to_str()\n" +
  "# Note this operation might have removed all previous comments. Sorry.\n" +
  "# If Riccardo wants to edit this, code is in: #{__FILE__}\n" +
  "---\n"
end

# https://stackoverflow.com/questions/4823468/comments-in-markdown
def add_markdown_comment(comment:)
  "[comment]: <> #{comment}"
end
#parsed = FrontMatterParser::Parser.parse_file('example.md')
def translate_title(title:, lang: )
  "[TODO] [#{lang}] #{title}".gsub('Geminocks', 'ðŸŽŒGemiNoTrnsl')
end

def alter_front_matter(file_name:,  extension:, lang:)
  alter_front_matter_version = '1.0'

  puts("alter_front_matter:: file_name: #{file_name}")
  parsed = FrontMatterParser::Parser.parse_file(file_name, loader: FMPLoader)
  # front_matter to hash
  altered_fm = parsed.front_matter
  #altered_fm ||= {} # Sometimes its empty - so be it
  raise "Empty FrontMatter for '#{file_name}'. Before ROCKING it, please add some --- stuff ---, thanks!" if altered_fm.nil?
  binding.pry if altered_fm.nil?
  altered_fm['geminock'] = {
    'alter_front_matter_version': alter_front_matter_version,
    'notes': 'Riccardo - todo make this variable per extension and calla  proper class to get it. So you can have a single thingie for Main picture, and then transform it for all extensions.'
  }
  altered_fm['title'] = translate_title(
    title: parsed.front_matter['title'],
    lang:)
  return altered_fm
end

# Calling Langchain
def call_gemini_on_content(markdown_content:, lang:) # , refresh_cache: false)

  prompt = Langchain::Prompt::PromptTemplate.new(
    template:File.read('etc/prompts/translate-to-another-language.prompt'),
    input_variables: ["full_name", "language", "original_content"]
  )

  formatted_prompt = prompt.format(
    original_content: markdown_content,
    language: short_lang_to_long(lang: ),
    full_name: 'Dr Riccardo Carlesso',
    )
  # DEBUG

  # Generate a unique cache key based on content hash and language
  FileUtils.mkdir_p('.cache/')
  cache_key = Digest::SHA256.hexdigest(markdown_content) + "-#{lang}.yaml"
  cache_file = ".cache/#{cache_key}"

  # Check for cached translation if overwrite is false and cache file exists
#  if !refresh_cache && File.exist?(cache_file)
  if File.exist?(cache_file)
    Langchain.logger.info("#{self.class} - â™»ï¸ Cache hit for #{cache_key.to_s[0..50]}...")
      # Read cached translation from YAML
    cached_data = YAML.load_file(cache_file)
    return cached_data["output"] if cached_data && cached_data["input"] == markdown_content
  end

  Langchain.logger.info("#{self.class} - â™»ï¸ Cache MISS for #{cache_key.to_s[0..50]}...")

  messages = [
    { role: "user", parts: [{ text: formatted_prompt }]}
  ]
  puts("Calling Gemini..")
  puts(formatted_prompt)
  response = llm.chat(messages: messages)

  # Prepare data for caching: input and output
  cache_data = {
    "input" => markdown_content,
    "output" => response.chat_completion, # ["messages"][0]["content"]
    "model" => GEMINI_MODEL,
    "code_version" => TranslatorVersion,
  }


  # Write the translation to the cache file
  File.open(cache_file, 'w') { |f| f.write(cache_data.to_yaml) }

  binding.pry if cache_data["output"].nil?

  # Return the translated content
  return cache_data["output"]

end

# This translates EVERYTHING, matter and content. Maybe I should just translate the content.
# TODO(rename to sth without translate..)
def translate_with_gemini(file_name:, extension:, lang:, output_file: , overwrite: false)

  # CHANGELOG:
  # 2024-10-20 v1.0 First iteration
  # 2024-10-20 v1.1 Add a "[Geminocks]" to title:
  # 2024-10-20 v1.2 Try to avoid the ``` output.
  prompt_version = '1.3'
  puts(Rainbow("WARNING! overwrite is TRUE! Gemini will now overwrite markdown file '#{output_file}' !!").red) if overwrite
  markdown_content = File.read(file_name)
  comment_ad_minchiam = "translate_with_gemini(file_name: #{file_name}, extension: #{extension}, lang: #{lang}). MD_content: #{markdown_content.length/1024}KB. prompt_version=#{prompt_version}"

  new_matter = alter_front_matter(file_name:,  extension:, lang:)

  # Geminize the whole stuff
  if ENABLE_GEMINI
    response_chat_completion = call_gemini_on_content(markdown_content: markdown_content, lang:)

    binding.pry if response_chat_completion.nil?

    # TODO do it well with https://www.rubydoc.info/gems/front_matter_parser/0.0.4

  #  gemini_output =  "# #{comment_ad_minchiam}\n\n#{response.chat_completion}" # + response
  #  gemini_output =  "<!-- #{comment_ad_minchiam} -->\n\n#{response.chat_completion}" # + response
    gemini_output = response_chat_completion + "\n\n*(Generated by Geminocks: https://github.com/palladius/ricc.rocks/tree/main/gemini prompt_version=#{prompt_version})*"
    #gemini_output = response.chat_completion + "\n\n<!--\n\n #{comment_ad_minchiam} \n\n-->"
    else
      puts("[TranslWGemini] no gemini BUT - let me just pass whatever i have in input and just do the FrontMatter magic.")
      parsed = FrontMatterParser::Parser.parse_file(file_name, loader: FMPLoader)
      new_doc_ohne_translation = matter_hash_to_str(new_matter) + "\n*[geminickl : DISABLED TRANSLATION BRO]*\n\n#{parsed.content}\n\nTHIS WAS ORIGINAL PARSED CONTENT"
      gemini_output = new_doc_ohne_translation
    end
# Write the modified content back to the output file
  ret = File.write(output_file, gemini_output)
  puts("[#{ret}] Just wrote MD to '#{output_file}'")
  return ret
end
