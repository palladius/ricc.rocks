---
# Generated by Geminock v1.9 . cache_key='5e596e03c6a7d7aeec571a0a20c4884f3ec56e1abef0b449afbaf5d1cde7741c-it.yaml'
geminock_ver: '1.9'

title: "ðŸ‡®ðŸ‡¹â™Š [Geminocks] Come ho impostato la traduzione automatica sul mio blog personale Hugo"
date: 2024-11-11
layout: single
author: Riccardo Carlesso
read_time: 3  # Minutes
# categories: Add categories if applicable (e.g., ruby, rails, gcp)
Tags: [hugo, netflify, blog, gcp, googlecloud, gemini, geminocks, Italian]
#canonicalURL: https://medium.com/@palladiusbonton/ruby-on-rails-with-postgresql-on-cloud-run-bdaaf0b26e0b
---

# Geminocks

https://ricc.rocks/ Ã¨ una gemma sottovalutata di contenuti preziosi, e non sono affatto di parte: Ã¨ il mio blog personale. ðŸ¤£

Al suo interno potete trovare le foto della mia famiglia, i miei sport e hobby, insieme ai miei articoli su Google Cloud. PerchÃ©? Mi sono semplicemente innamorato
del markdown e sono stato indirizzato dai miei colleghi a Hugo. Come rubyist, mi sembra di tradire `jekyll`, lo so.

## La configurazione del mio blog

Uso una configurazione molto semplice:

* Github per archiviare il codice
* Netlify per la compilazione automatica
* Dominio `ricc.rocks` per ospitarlo. E questo Ã¨ tutto.

## Il problema della lingua

Tuttavia, un blog che si rispetti dovrebbe avere almeno una versione in inglese e una nella propria lingua madre (ðŸ‡®ðŸ‡¹ nel mio caso).

DHH mi ha contagiato con l'ossessione per il DRY, quindi ora non posso vivere in modo non-DRY. Cosa succede se traduco manualmente i contenuti? Domani aggiorno il contenuto e devo aggiornare anche la/le traduzione/i.
Inoltre parlo alcune lingue, quindi questo diventa spaventoso abbastanza velocemente. Gli LLM sono bravi a tradurre, quindi perchÃ© non provare a usare Gemini per fare il lavoro pesante?

Ci sono alcune sfide perÃ²: un markdown di Hugo inizia con il cosiddetto "Front Matter"; questo contiene alcune coppie chiave-valore in formato YAML.
Voglio tradurre l'intera pagina e lasciare intatto il Front Matter. Il mio LLM sarÃ  all'altezza del compito? Ho scoperto che funziona abbastanza bene finchÃ©...
non provi il giapponese!


## Testare lo script

**Come si testa l'output di un LLM e la qualitÃ  del prompt?**

Ecco **PromptFoo**! Promptfoo Ã¨ una libreria fantastica in cui Ã¨ possibile impostare unit test per l'output del LLM sia in modo deterministico
che LLMistico (perdonate i miei neologismi).

Se voglio assicurarmi che l'output di LLM sia in grado di gestire il giapponese (si Ã¨ confuso alcune volte).

Immagina di avere un prompt che Ã¨ parametrico in Lingua, nome completo (Ã¨ sempre il mio nome) e contenuto del file.

Bene, puoi scrivere cose come:

```yaml

  - vars:
      language: japanese
      full_name: Riccardo Carlesso
      original_content: 'file://../../src/posts/medium/2022-09-12-GCP-CB-trigger-with-pulumi-python/index.md'
    assert:
      - type: llm-rubric
        value: |
          Il Front Matter contiene una chiave `tag:` e contiene 'geminock' e 'japanese'.
      - type: llm-rubric
        value: |
          Il Front Matter contiene una chiave `title:` racchiusa tra virgolette doppie, cioÃ¨ una riga di questo tipo:
          title: "<qualche informazione qui>"
          All'interno del titolo dovrebbe esserci una bandiera del Giappone.
```

Ora un LLM creerÃ  (e memorizzerÃ  nella cache!) il contenuto LLM ed eseguirÃ  questi due test. Questi test derivano dalla mia esperienza:
Ho notato che quando Gemini traduce in giapponese, a volte il titolo non Ã¨ nella forma `title: "blah blah"` ma nella forma
`title: blah blah` che non funziona bene con i kanji, quindi voglio assicurarmi che sia tra virgolette doppie.

Questo Ã¨ un possibile output:

![promptfoo output](image.png)


*(Generated by Geminocks: https://github.com/palladius/ricc.rocks/tree/main/gemini prompt_version=1.4)*

---
title: "[TODO] [it] \U0001F38CGemiNoTrnsl: how I set-up auto-translation on my personal
  Hugo Blog"
date: 2024-11-11
layout: single
author: Riccardo Carlesso
read_time: 3
Tags:
- hugo
- netflify
- blog
- gcp
- googlecloud
- gemini
- geminocks
geminock:
  :alter_front_matter_version: '1.0'
  :notes: Riccardo - todo make this variable per extension and calla  proper class
    to get it. So you can have a single thingie for Main picture, and then transform
    it for all extensions.
# Generated by Geminock v.1.9 - matter_hash_to_str()
# Note this operation might have removed all previous comments. Sorry.
# If Riccardo wants to edit this, code is in: /usr/local/google/home/ricc/git/ricc.rocks/gemini/lib/gemini/translator.rb
---
